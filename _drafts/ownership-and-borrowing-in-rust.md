---
layout:   post
title:    "Владение и заимствование в Rust"
date:     2018-08-26 09:00:00 +0300
tags:     post rust tutorial
comments: true
---

**Владение** и **заимствование** являются центральными понятиями языка Rust.
Именно они являются главным источником гарантий безопасной работы с памятью.
С ними компилятор становится способен отслеживать _время жизни_ объектов,
что позволяет ему доказывать ряд интересных свойств программ.
Некоторые свойства гарантируют отсутствие нежелательного поведения программ.
Другие позволяют компилятору применять иначе невозможные оптимизации.
И что самое любопытное:
Rust добивается этого при полностью детерминированном управлении ресурсами,
без использования сборщика мусора для памяти.

В этой заметке повсеместно используются понятия _объектов_ и _ресурсов_.
Они являются «очевидными» для большинства программистов,
поэтому никто особо не задумывается о смысле,
который вкладывается в эти понятия.
Я написал [небольшую вспомогательную заметку][1],
где собрал философское переливание из пустого в порожнее,
объясняющее эти понятия и их аспекты.
Полезно для приведения мировоззрения в порядок,
но не является технически интересной информацией.

[1]: /2018/08/27/on-resources-and-objects.html

<hr/>

# Владение и заимствование

- В языке есть объекты, с которыми можно взаимодействовать
- Не рождёнными и мёртвыми объектами пользоваться нельзя
- Время жизни объекта определяется его владельцем
- Владение привязано к переменным
- Владение можно навсегда передать в другую переменную
- Объект можно временно позаимствовать с помощью ссылок

# Ссылки, переменные и владение в Rust

## Фундаментальные типы ссылок

- Владеющая ссылка на объект
- Категория изменяемости
- Копирование объектов
- Заимствующие ссылки
- Правила алиасинга
- Сырые указатели

## Производные типы ссылок

- Коробки: Box
- Счётчики ссылок: Rc, Arc
- Ячейки: Cell, RefCell
- Мьютексы: Mutex, RwLock
- Перемещаемость между потоками

# Сравнение с другими языками

## C++

- Перемещение не инвалидирует ссылки
- Ссылки не дают гарантий алиасинга

## Java

- Объектами владеет сборщик мусора
- Один фундаментальный тип ссылок упрощает программы
- Побочные эффекты автоматического управления памятью

# Проблемы, которые предотвращает Rust

- Разыменование нулевых указателей
- Обращение к неинициализированным данным
- Использование мёртвых объектов
  - Инвалидация итераторов
  - Использование перемещённых значений
  - Возврат локальных переменных
  - Временные значения
  - Утечка ссылок
- Одновременная модификация
  - Проход по изменяющиейся коллекции
  - Косвенное разделение данных
  - Работает и для нескольких потоков

# Оптимизации, которые позволяет Rust

- Проверки на null и границы массивов
- Важность алиасинга для компиляторов
- Когда C++ мешает оптимизациям
- Примеры оптимизаций (с Godbolt)

# Новые идиомы дизайна API в Rust

- Передача с транформацией
  - Комбинаторы итераторов
  - Смена состояний объекта
- Безопасные zero-copy слайсы
- ???

<hr/>

https://polyfloyd.net/post/how-rust-helps-you-prevent-bugs/
