---
layout:   post
title:    "Владение и заимствование в Rust"
date:     2018-08-26 09:00:00 +0300
tags:     post rust tutorial
comments: true
---

**Владение** и **заимствование** являются центральными понятиями языка Rust.
Именно они являются главным источником гарантий безопасной работы с памятью.
С ними компилятор становится способен отслеживать _время жизни_ объектов,
что позволяет ему доказывать ряд интересных свойств программ.
Некоторые свойства гарантируют отсутствие нежелательного поведения программ.
Другие позволяют компилятору применять иначе невозможные оптимизации.
И что самое любопытное:
Rust добивается этого при полностью детерминированном управлении ресурсами,
без использования сборщика мусора для памяти.

## О ресурсах и объектах

Начнём мы с некоторого лирического отступления о философских понятиях в языках программирования.
Они «очевидны» всем программистам,
но не всякий задумывается об их смысле
и том, как это влияет на процесс программирования.

Весь этот раздел при желании можно пропустить,
так как он содержит философское переливание из пустого в порожнее.
Это полезно для приведения мировоззрения в порядок,
но не является технически интересной информацией.

### Понятия объектов и ресурсов

В языках программирования существует понятие _полноценных объектов_
(или объектов _первого класса_).
Это объекты, которыми программа может непосредственно оперировать.
Например: числа, строки, составные структуры данных.
Подобные объекты доступны в большинстве языков программирования.
В некоторых языках к этому списку добавляются указатели, функции, типы данных,
модули, синтаксис программ.
Грубо говоря, полноценный объект — это то, что можно сохранить в переменную.

У объектов есть некоторое _время жизни_ —
отрезок времени, на котором объект существует.
По определению, программы не могут оперировать несуществующими объектами.
Ещё не рождённые объекты и уже умершие объекты недоступны для программ.

В программах также существует понятие _ресурсов_, полученных от операционной системы.
Например: память, файлы, сокеты, окна, потоки.
Программы могут взаимодействовать с ресурсами.
Как и объекты, ресурсы имеют некоторое время жизни.
Программам не следут взаимодействовать с ресурсами за пределами их времени жизни,
так как неинициализированные или освобождённые ресурсы не имеют определённого состояния.

### Связь между объектами и ресурсами

Каждый объект языка неразрывно связан как минимум с одним ресурсом: памятью.
У объектов есть состояние,
которое необходимо где-то хранить,
поэтому (почти) все они потребляют память.
Некоторые объекты потребляют и другие ресурсы:
скажем, файлы требуют открытых файловых дескрипторов.

Обратное верно не всегда:
не всем ресурсам,
которые операционная система выдаёт программе,
соответствуют объекты в программе.
Например, процессорное время обычно не имеет соответствующего объекта.
Некоторые ресурсы языками программирования исторически не признавались таковыми:
например, захваченный мьютекс можно воспринимать как вполне себе исчерпаемый ресурс.
В большинстве популярных современных языков программирования
(до недавнего времени)
захваченные мьютексы не представляются отдельными объектами.
Они существуют лишь как состояние всего объекта «мьютекс»,
которое само по себе не является полноценным объектом.

Парадигма,
когда ресурсы неразрывно связаны с объектами,
называется _resource acquisition is initialiazation_ (RAII).
Ресурс передаётся программе при создании объекта
и освобождается при уничтожении объекта.
Таким образом, время жизни ресурса определяется временем жизни объекта.
Это упрощает написание программ,
так как теперь надо оперировать лишь одной сущностью вместо двух.

### Автоматическое и ручное управление временем жизни

Исторически, все ресурсы управлялись программами _вручную_.
Получить новую память можно с помощью функции `malloc()`.
Освободить ненужную память можно с помощью функции `free()`.
Или с помощью операторов `new` и `delete`,
или методами `alloc` и `dealloc`.

Пионером автоматического управления временем жизни ресурсов
стала технология _сборки мусора_
(придуманная в 1959 году).
Она позволяет управлять памятью _автоматически_:
программам больше не следует волноваться о выделении и освобождении памяти,
о её распределении между множеством объектов
и повторном использовании.
За всё это теперь отвечает _система времени исполнения_ (рантайм).
Так же как операционная система отвечает за автоматическое управление такими ресурсами
как процессорное время, физическая память или доступ к сетевым интерфейсам.

К сожалению, для других ресурсов подобная технология чаще всего не применима.
Выделение и освобождение памяти (условно) не влияет на другие объекты и процессы в системе.
Именно это позволяет управлять ею автоматически.
В то же время, например,
файловые дескрипторы являются очень ограниченным ресурсом:
обычно процесс может одновременно открыть около тысячи файлов,
в противовес буквально терабайтам доступной виртуальной памяти.

Кроме того, открытые файлы могут влиять на другие части системы:
в Windows открытый кем-то файл нельзя удалить.
Аналогично, захваченный мьютекс имеет очень существенное влияние на поведение программы.
Программы рассчитывают на определённый порядок работы с мьютексами,
но определение этого порядка является алгоритмически неразрешимой задачей,
а эвристики дают неудовлетворительные результаты.
Поэтому некоторые ресурсы всё ещё управляются программистами вручную.

### Явное и неявное управление временем жизни

В случае ручного управления памятью в Си
её необходимо _явно_ освобождать, вызывая функцию `free()`.
Если этого явно не сделает программист, то память освобождена не будет.
Компилятор не вставляет никаких деструкторов.

В то же время, память на стеке управляется _неявно_:
компилятор самостоятельно выделяет и освобождает память под локальные переменные.
_Умные указатели_ позволяют неявно управлять и памятью в куче,
косвенно используя неявное управление временем жизни локальных переменных.
Аналогичный подход применим и к другим ресурсам,
таким как открытые файлы и захваченные мьютексы.

### Детерминированность времени жизни

Это понятие близко к осям «автоматический — ручной» и «явный — неявный»,
однако не совпадает с ними полностью.
Лучше всего оно описывается синонимами «очевидность» и «предсказуемость».
_Детерминированность_ важна для некоторых ресурсов
вроде захватов мьютексов или отката транзакций.
Предсказуемость порядка и времени событий,
происходящих с подобными ресурсами,
играет очень важную роль для корректности и эффективности программ.

Здесь важную роль играет то, как текст программы соотносится с ресурсами.
Например, в случае автоматического управления памятью
текст программы точно определяет время жизни памяти для объектов:
если объектом вообще можно оперировать, то память под него всё ещё на месте.
Однако, время освобождения памяти никак не определено.
Сборщик мусора в принципе может её вообще не освобождать до самой смерти процесса.

В случае ручного управления памятью момент освобождения вполне себе детерминирован:
очевидно — в тот момент, когда вызывается `free()`.
Однако, время жизни объекта при этом в общем случае недетерминировано:
в программе можно выразить сколь угодно сложную логику,
определяющую точный момент освобождения памяти.

_Автоматизированное_ управление памятью с помощью стека и, например, подсчёта ссылок
позволяет управлять детерминированностью, обменивая её на выразительность.
Простые случаи остаются детерминированными.
В сложных программах мы всё ещё сталкиваемся с недетерминированностью:
освобождение одного объекта может вызвать сложно предсказуемый каскад
освобождений вложенных объектов.

<hr/>

# Владение и заимствование

- В языке есть объекты, с которыми можно взаимодействовать
- Не рождёнными и мёртвыми объектами пользоваться нельзя
- Время жизни объекта определяется его владельцем
- Владение привязано к переменным
- Владение можно навсегда передать в другую переменную
- Объект можно временно позаимствовать с помощью ссылок

# Ссылки, переменные и владение в Rust

## Фундаментальные типы ссылок

- Владеющая ссылка на объект
- Категория изменяемости
- Копирование объектов
- Заимствующие ссылки
- Правила алиасинга
- Сырые указатели

## Производные типы ссылок

- Коробки: Box
- Счётчики ссылок: Rc, Arc
- Ячейки: Cell, RefCell
- Мьютексы: Mutex, RwLock
- Перемещаемость между потоками

# Сравнение с другими языками

## C++

- Перемещение не инвалидирует ссылки
- Ссылки не дают гарантий алиасинга

## Java

- Объектами владеет сборщик мусора
- Один фундаментальный тип ссылок упрощает программы
- Побочные эффекты автоматического управления памятью

# Проблемы, которые предотвращает Rust

- Разыменование нулевых указателей
- Обращение к неинициализированным данным
- Использование мёртвых объектов
  - Инвалидация итераторов
  - Использование перемещённых значений
  - Возврат локальных переменных
  - Временные значения
  - Утечка ссылок
- Одновременная модификация
  - Проход по изменяющиейся коллекции
  - Косвенное разделение данных
  - Работает и для нескольких потоков

# Оптимизации, которые позволяет Rust

- Проверки на null и границы массивов
- Важность алиасинга для компиляторов
- Когда C++ мешает оптимизациям
- Примеры оптимизаций (с Godbolt)

# Новые идиомы дизайна API в Rust

- Передача с транформацией
  - Комбинаторы итераторов
  - Смена состояний объекта
- Безопасные zero-copy слайсы
- ???

<hr/>

https://polyfloyd.net/post/how-rust-helps-you-prevent-bugs/
