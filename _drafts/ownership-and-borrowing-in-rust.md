---
layout:   post
title:    "Владение и заимствование в Rust"
date:     2018-08-26 09:00:00 +0300
tags:     post rust tutorial
comments: true
---

**_Владение и заимствование_** являются центральными понятиями языка Rust.
Именно они являются главным источником гарантий безопасной работы с памятью.
С ними компилятор становится способен отслеживать _время жизни_ объектов,
что позволяет ему доказывать ряд интересных свойств программ.
Некоторые свойства гарантируют отсутствие нежелательного поведения программ.
Другие позволяют компилятору применять иначе невозможные оптимизации.
И что самое любопытное:
Rust добивается этого при полностью детерминированном управлении ресурсами,
без использования сборщика мусора для памяти.

В этой заметке повсеместно используются понятия _объектов_ и _ресурсов_.
Они являются «очевидными» для большинства программистов,
поэтому никто особо не задумывается о смысле,
который вкладывается в эти понятия.
Я написал [небольшую вспомогательную заметку][1],
где собрал философское переливание из пустого в порожнее,
объясняющее эти понятия и их аспекты.
Полезно для приведения мировоззрения в порядок,
но не является технически интересной информацией.

[1]: /2018/08/27/on-resources-and-objects.html

## Владение и заимствование

В программах на Rust время жизни объектов связано с переменными
(принцип RAII).

```rust
fn some_function() {
    let numbers = vec![1, 2, 3];

    // `numbers` are alive until the end of this function,
    // and will be destroyed when the function returns.
}
```

У каждого объекта есть _владелец_,
ответственный за уничтожение объекта и связанных с ним ресурсов.

### Кто может быть владельцем

В случае глобальных переменных владельцем является вся программа
(или один из её потоков в случае thread-local переменных).
Объекты уничтожаются при завершении соответствующих потоков.

```rust
static NUMBERS: Vec<i32> = vec![1, 2, 3];
```

Локальные переменные и аргументы функций тоже могут владеть объектами.
Они уничтожают свои объекты в соответствии с вложенностью областей видимости.

```rust
fn make_numbers(count: i32) -> Vec<i32> {
    let mut result = Vec::new();
    let mut prev = 0;

    for i in 0..count {
        let next = prev + i;
        result.append(next);
        prev = next;
    }

    result
}
```

Переменная `next` рождается и умирает на каждой итерации цикла.
Переменные `count`, `result`, `prev` будут освобождены при выходе из `make_numbers()`.
Однако, возвращаемый вектор при этом не уничтожается,
так как владение над ним было _передано_ вызывающей функции.

Наконец, объектами могут владеть другие объекты.

```rust
let files: Vec<Result<io::File, io::Error>> =
    (1..10).iter()
      .map(|n| File::open(format!("file_{}.txt", n)))
      .collect();
```

Открытые файлы, хранящиеся в векторе, будут закрыты при уничтожении вектора
(или когда они будут оттуда убраны при изменения размера вектора, например).

### Передача владения

У объекта на уровне языка всегда _один владелец_ —
одна конечная сущность,
ответственная за уничтожение объекта,
и она уничтожит объект только один раз.
Это правило гарантирует отсутствие ошибок класса double-free.

Владение над объектом можно передавать.
Это делается с помощью присваивания `=`.

```rust
let numbers = vec![1, 2, 3, 4, 5];

let other_numbers = numbers;
```

Переменная,
у которой отобрали владение,
больше не ссылается ни на какой объект.
Такими переменными пользоваться нельзя.
Компилятор это отслеживает и гарантирует отсутствие ошибок класса use-after-move.

```
error[E0382]: use of moved value: `numbers`
 --> src/main.rs:6:20
  |
4 |     let other_numbers = numbers;
  |         ------------- value moved here
5 |
6 |     println!("{}", numbers[0]);
  |                    ^^^^^^^ value used here after move
  |
  = note: move occurs because `numbers` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
```

### Дерево владения

Если отобразить отношения владения между объектами в виде направленного графа,
то этот граф окажется _лесом деревьев_.
У каждого объекта есть один владелец:
в каждый узел входит не более одного ребра.
Объект также не может быть владельцем самого себя.
Виртуальными владельцами корневых объектов являются потоки.

У деревьев много интересных свойств.
Одно из них: в деревьях нет циклов.
Используя безопасный Rust нельзя создать цикл из владеющих ссылок.
Можно воспринимать это утвеждение как слабую гарантию отсутствия утечек памяти.
На самом деле в языке есть механизмы,
позволяющие обойти эти ограничения.

Fun fact:
это также означает,
что вы не сможете реализовать двухсвязный список
используя лишь владеющие ссылки.
Это можно сделать с помощью других механизмов языка,
но только примитивными типами здесь не обойтись.

### Что за заимствование

Допустим у вас есть вектор:

```rust
let numbers = vec![1, 2, 3, 4, 5];
```

Вы хотите написать функцию,
которая вычислит сумму элементов в векторе:

```rust
fn sum(numbers: Vec<i32>) -> i32 {
    numbers.iter().sum()
}
```

Затем вывести её на экран,
а потом — элементы вектора:

```rust
println!("Sum: {}", sum(numbers));

for (i, n) in numbers.iter().enumerate() {
    println!("vec[{}] = {}", i, n);
}
```

Это не сработает,
потому что мы переместили вектор в функцию `sum()`
и она его уже освободила:

```
error[E0382]: use of moved value: `numbers`
  --> src/main.rs:10:19
   |
8  |     println!("Sum: {}", sum(numbers));
   |                             ------- value moved here
9  |
10 |     for (i, n) in numbers.iter().enumerate() {
   |                   ^^^^^^^ value used here after move
   |
   = note: move occurs because `numbers` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
```

Что делать?
Можно попросить функцию вернуть вектор обратно:

```rust
fn sum(numbers: Vec<i32>) -> (i32, Vec<i32>) {
    (numbers.iter().sum(), numbers)
}
```

```rust
let numbers = vec![1, 2, 3, 4, 5];

let (sum, numbers) = sum(numbers);

println!("Sum: {}", sum);

for (i, n) in numbers.iter().enumerate() {
    println!("vec[{}] = {}", i, n);
}
```

Но это как-то глупо, правда?

Rust позволяет функции временно _позаимствовать_ вектор.
`sum()` получит право распоряжаться вектором на своё усмотрение,
за исключением права его уничтожения.

```rust
fn sum(numbers: &Vec<i32>) -> i32 {
    numbers.iter().sum()
}
```

```rust
println!("Sum: {}", sum(&numbers));
```

Всё как с реальным имуществом.
Даже можно перезанимать объекты другим функциям.
Главный секрет в том,
что компилятор строго следит за соблюдением законов.

## Правила владения

Что же это за правила, которым следует rustc?

* Освобождай ресурсы объекта твоего, и лишь однажды.

  Компилятор всегда вставляет вызовы деструкторов
  (метод `drop()` трейта `Drop`)
  и освобождает память на стеке.
  Программист не может случайно забыть это сделать
  (но при надобности может намеренно отказаться).

  Кроме того, компилятор следит за тем,
  чтобы у объекта всегда был только один владелец,
  предотвращая повторное освобождение ресурсов объекта.

* Давай другим читать твоим объекты.

  Владелец может одалживать объект с правом чтения,
  создавая _читающие_ ссылки `&T`.
  Такие ссылки позволяют получить доступ к состоянию объекта,
  но не позволяют его модификацию.
  Естественно, через них также нельзя получить или передать владение.
  Таких ссылок можно создавать сколько угодно.
  Они также распространяются на составные части объекта.

* Лишь одному позволено изменять объект.

  Владелец может одолжить объект с правом модификации,
  создав _мутирующую_ ссылку `&mut T`.
  Она позволяет всё то же, что и читающая,
  но вдобавок позволяет изменять состояние объекта.
  Объект при этом всё ещё остаётся заимствованным:
  мутирующую ссылку нельзя превратить во владеющую.
  Важный момент состоит в том, что программе в каждый момент времени
  позволено иметь не больше одной мутирующей ссылки на каждый объект.
  Это правило распространяется и на составные части объекта.

* Не смешивай в одной программе читающие и мутирующие ссылки.

  Владельцу запрещено создавать читающие ссылки,
  пока где-то есть мутирующая,
  и создавать мутирующую ссылку,
  если где-то есть хотя бы одна читающая.
  Чтобы одолжить кому-либо объект для чтения,
  необходимо сначала закончить с его модификацией.
  Компилятор откажется собирать программу,
  которая пытается поступить иначе.

  Это правило имеет очень далеко идущие последствия,
  которые позже будут рассмотрены чуть детальнее.
  Программисты даже не задумываются,
  насколько часто они одалживают объекты в самых неожиданных местах.

* Не прикасайся к чужим объектам сам и не позволяй другим.

  Передать владение или уничтожить объект можно
  только при условии отсутствия ссылок на него.
  Компилятор не позволяет переместить объект,
  пока в программе есть ссылки на него,
  и не позволит создавать ссылку на перемещённый или уничтоженный объект.

  Это правило тоже любят нарушать в самых неожиданных местах.
  К счастью, оно не распространяется на _копии_ объектов.

Как видим, правила владения в Rust предотвращают
пользование объектами за пределами их времени жизни,
а правила заимствования по сути реализуют _read-write lock_,
синхронизирующий доступ к разделяемым данным.
И всё это выполняется во время компиляции,
с нулевой стоимостью во время исполнения программы.

## Фундаментальные ссылки в Rust

Рассмотрим ещё раз с примерами основные типы ссылок,
которыми оперирует Rust.
Все они являются фундаментальными для языка
(то есть определены компилятором, не библиотеками).

### Владеющая ссылка `T`

Самый простой тип ссылок: собственно значение.
Ссылкой он называется условно,
так как это на самом деле не адрес в памяти,
но для компилятора все переменные —
это ссылки _куда-то_ (в память, на регистр).

Владеющая ссылка определяет время жизни объекта,
во время которого он доступен программе для взаимодействия.
При выходе владеющей ссылки из области видимости
соответствующий объект уничтожается
и становится недоступен.

```rust
fn main() {
    let numbers = vec![1, 2, 3];

    // ...
}
```

```

o  numbers
|
|
X
```

### Передача владения

Владение можно передавать между переменными.
Например, с помощью присваивания:

```rust
fn main() {
    let numbers = vec![1, 2, 3];

    // ...

    let mut new_numbers = numbers;

    // ...
}
```

```

o  numbers
|
|
> - - o  new_numbers
      |
      |
      X
```

В этом случае переменная `numbers` больше не владеет вектором,
вместо неё на этот же вектор ссылается переменная `new_numbers`.
Теперь она будет отвечать за уничтожение вектора.
Переменной `numbers` теперь пользоваться нельзя:

```rust
fn main() {
    let numbers = vec![1, 2, 3];
    let mut new_numbers = numbers;
    println!("{}", numbers[0]);
}
```

```
```

Точно так же владение можно передавать функции,
которая будет обязана уничтожить вектор перед возвратом управления:

```rust
fn main() {
    let numbers = vec![1, 2, 3];

    print_numbers(numbers);
}

fn print_numbers(numbers: Vec<i32>) {
    println!("{:?}", numbers);
}
```

```
o numbers (main)
|
|
> - - o numbers (print_numbers)
      |
      |
      X
```

Или вектор можно сохранить в новую структуру данных,
которой тоже будет кто-то владеть и она уже освободит все всои поля:

```rust
fn main() {
    let numbers1 = vec![1, 2, 3];
    let numbers2 = vec![4, 5, 6];
    let sequences = Sequences {
        one: numbers1,
        two: numbers2,
    };
}

struct Sequence {
    one: Vec<i32>,
    two: Vec<i32>,
}
```

```
oo numbers1, numbers2
||
||
>> - - o.. sequences
       |||
       |||
       |xx sequences.one, sequences.two
       X
```

### Маркер `Copy`

### Читающая ссылка `&T`

### Мутирующая ссылка `&mut T`

### Сырые указатели `*const T` и `*mut T`

<hr/>

# Ссылки, переменные и владение в Rust

## Фундаментальные типы ссылок

- Владеющая ссылка на объект
- Категория изменяемости
- Копирование объектов
- Заимствующие ссылки
- Правила алиасинга
- Сырые указатели

## Производные типы ссылок

- Коробки: Box
- Счётчики ссылок: Rc, Arc
- Ячейки: Cell, RefCell
- Мьютексы: Mutex, RwLock
- Перемещаемость между потоками

# Сравнение с другими языками

## C++

- Перемещение не инвалидирует ссылки
- Ссылки не дают гарантий алиасинга

## Java

- Объектами владеет сборщик мусора
- Один фундаментальный тип ссылок упрощает программы
- Побочные эффекты автоматического управления памятью

# Проблемы, которые предотвращает Rust

- Разыменование нулевых указателей
- Обращение к неинициализированным данным
- Использование мёртвых объектов
  - Инвалидация итераторов
  - Использование перемещённых значений
  - Возврат локальных переменных
  - Временные значения
  - Утечка ссылок
- Одновременная модификация
  - Проход по изменяющиейся коллекции
  - Косвенное разделение данных
  - Работает и для нескольких потоков

# Оптимизации, которые позволяет Rust

- Проверки на null и границы массивов
- Важность алиасинга для компиляторов
- Когда C++ мешает оптимизациям
- Примеры оптимизаций (с Godbolt)

# Новые идиомы дизайна API в Rust

- Передача с транформацией
  - Комбинаторы итераторов
  - Смена состояний объекта
- Безопасные zero-copy слайсы
- ???

<hr/>

https://polyfloyd.net/post/how-rust-helps-you-prevent-bugs/
